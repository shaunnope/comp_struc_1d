/**
test circuit FSM for two 16b inputs
   Inputs: clk, rst, irq signals
   Outputs: alufn signal, mode and case indices, slowClock value
*/
module alu_fsm (
    input clk,  // slowClock
    input rst,  // reset
    input irq,  // interuppt it no match
    input mCon[4],
    output alufn_signal[5],
    output alu_mode[4],
    output index[5],
    output clkvalue[6] // debugging
  ) {
  
  .clk(clk){    
    .rst(rst){
      counter xClock(#SIZE(6), #DIV(0));
      
      fsm testAluFsm = {ADD, SUB, MUL, DIV, SHL, SHR, SRA, ROL, CMPEQ, CMPLT, CMPLE, AND, OR, XOR, A, B, HALT};
      
      // holding values
      dff alufn[5];    // alufn signal
      dff modeidx[4];  // mode index
      dff caseidx[5];  // case index
    }
    edge_detector clockEdge(#RISE(1), #FALL(1));
    edge_detector changeMode(#RISE(1), #FALL(1));
  }

  always {
    clockEdge.in = xClock.value[0];
    changeMode.in = xClock.value[5];
    clkvalue = xClock.value;
    
    if (rst & 1){
        modeidx.d = 4b0000;
        caseidx.d = 5b00000;
        alufn.d = 5b00000;
        testAluFsm.d = testAluFsm.ADD;
    } else if (irq & 1) {
      testAluFsm.d = testAluFsm.HALT;
    }
    else if (testAluFsm.q != testAluFsm.HALT) { // only change states if not HALT
      if (clockEdge.out == b1){ // only change input when LSB of slowCLock changes
       caseidx.d = caseidx.q + 1;
      }
      //if (changeMode.out == b1){// only change mode after 32 cases
      if (mCon[0] == b1){
       modeidx.d = modeidx.q + 1;
       case(modeidx.q) {
        b0000: testAluFsm.d = testAluFsm.ADD;
        b0001: testAluFsm.d = testAluFsm.SUB;
        b0010: testAluFsm.d = testAluFsm.MUL;
        b0011: testAluFsm.d = testAluFsm.DIV;
        b0100: testAluFsm.d = testAluFsm.SHL;
        b0101: testAluFsm.d = testAluFsm.SHR;
        b0110: testAluFsm.d = testAluFsm.SRA;
        b0111: testAluFsm.d = testAluFsm.ROL;
        b1000: testAluFsm.d = testAluFsm.CMPEQ;
        b1001: testAluFsm.d = testAluFsm.CMPLT;
        b1010: testAluFsm.d = testAluFsm.CMPLE;
        b1011: testAluFsm.d = testAluFsm.XOR;
        b1100: testAluFsm.d = testAluFsm.OR;
        b1101: testAluFsm.d = testAluFsm.A;
        b1110: testAluFsm.d = testAluFsm.AND;
        b1111: testAluFsm.d = testAluFsm.B;
        default: testAluFsm.d = testAluFsm.ADD;
        }
      }
    }
    
    // output alufn signal
    case(testAluFsm.q){
      testAluFsm.ADD : 
              alufn.d = b00000;
      testAluFsm.SUB : 
              alufn.d = b00001;     
      testAluFsm.MUL : 
              alufn.d = b00010; 
      testAluFsm.DIV : 
              alufn.d = b00011; 
      testAluFsm.SHL : 
              alufn.d = b00100;      
      testAluFsm.SHR : 
              alufn.d = b00101; 
      testAluFsm.ROL : 
              alufn.d = b00110;      
      testAluFsm.SRA : 
              alufn.d = b00111;
      testAluFsm.CMPEQ : 
              alufn.d = b01011;
      testAluFsm.CMPLT : 
              alufn.d = b01101;     
      testAluFsm.CMPLE : 
              alufn.d = b01111;
      testAluFsm.XOR : 
              alufn.d = b10110;
      testAluFsm.OR : 
              alufn.d = b11110;  
      testAluFsm.A : 
              alufn.d = b11010;     
      testAluFsm.AND : 
              alufn.d = b11000;
      testAluFsm.B : 
              alufn.d = b11100;
      testAluFsm.HALT:
              alufn.d = alufn.q;        
      default:
              alufn.d = b000000;
              testAluFsm.d = testAluFsm.ADD;

  }
    
    alufn_signal = alufn.q;
    alu_mode = modeidx.q;
    index = caseidx.q;
}

/*
TO DO:
All other truth tables for b01xxxx truth table
Parity ZVN tester?

1st clock cycle: FSM sends x, y  and ALUFN to ALU. ALU computes answer
2nd clock cycle: FSM sends correct answer to ALU, ALU XORs correct answer and computed value, shows error code.

register required to store computed answer for the next clock cycle?
Think of possible error codes.



*/