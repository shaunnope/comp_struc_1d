module alu_tester (
    input clk,  // clock
    input reset,
    output out[6] // alufn signals
  ) {
  
  .clk(clk){
    fsm testAluFsm={ADD, SUB, MUL, DIV, AND, OR, XOR, A, B, SHL, SHR, SRA, CMPEQ, CMPLT, CMPLE}; 
  }

  always {
  
    if (reset & 1){
        testAluFsm.d = testAluFsm.ADD;
    }
    else{
        testAluFsm.d = testAluFsm.q;
    }
    out = 6b0;
    case(testAluFsm.q){
      testAluFsm.ADD : 
              out = b000000;
              testAluFsm.d = testAluFsm.SUB;
      testAluFsm.SUB : 
              out = b000001;
              testAluFsm.d = testAluFsm.MUL;
      testAluFsm.MUL : 
              out = b000010;
              testAluFsm.d = testAluFsm.DIV;    
      testAluFsm.DIV : 
              out = b000010;
              testAluFsm.d = testAluFsm.AND;           
      testAluFsm.AND : 
              out = b011000;
              testAluFsm.d = testAluFsm.OR;  
      testAluFsm.OR : 
              out = b011110;
              testAluFsm.d = testAluFsm.XOR;        
      testAluFsm.XOR : 
              out = b010110;
              testAluFsm.d = testAluFsm.A;        
      testAluFsm.A : 
              out = b011010;
              testAluFsm.d = testAluFsm.B;    
      testAluFsm.B : 
              out = b011010;
              testAluFsm.d = testAluFsm.SHL;     
      testAluFsm.SHL : 
              out = b100000;
              testAluFsm.d = testAluFsm.SHR;        
      testAluFsm.SHR : 
              out = b100001;
              testAluFsm.d = testAluFsm.SRA;        
      testAluFsm.SRA : 
              out = b100011;
              testAluFsm.d = testAluFsm.CMPEQ; 
      testAluFsm.CMPEQ : 
              out = b110011;
              testAluFsm.d = testAluFsm.CMPLT;
      testAluFsm.CMPLT : 
              out = b110101;
              testAluFsm.d = testAluFsm.CMPLE;        
      testAluFsm.CMPLE : 
              out = b110111;
              testAluFsm.d = testAluFsm.ADD;
      default:
              out = b000000;
              testAluFsm.d = testAluFsm.ADD;      
                          
    }
  }
}

/*
TO DO:
DIV
All other truth tables for b01xxxx truth table
Parity ZVN tester?

1st clock cycle: FSM sends x, y  and ALUFN to ALU. ALU computes answer
2nd clock cycle: FSM sends correct answer to ALU, ALU XORs correct answer and computed value, shows error code.

register required to store computed answer for the next clock cycle?
Think of possible error codes.



*/