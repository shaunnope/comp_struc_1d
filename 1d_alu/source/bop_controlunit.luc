module bop_controlunit (
    input clk,  // clock
    input rst,  // reset
    input slwclk,   // Used for stages
    
    input inputs[4],   // 3 buttons, 1 did smth
    input start,     // start button need edge detector
    
    input level[2], // 2 bit to represent 3 levels, 01 = level 1
    input rb_data[16],
    input zvnpc[5],

    output alufn[5],
    output asel, 
    output bsel[2],
    output werf,
    output wdsel[2],
    output lit[4],
    output rc[3],
    output ra[3],
    output rb[3],
    output bzsel // Used for sound buzzer
  ) {
  
  .clk(clk){
    edge_detector input_edges[4] (#RISE(1), #FALL(0));
    edge_detector clk_edge[2] (#RISE(1), #FALL(0));
    
    fsm game_fsm = {
      // Varshini
      START,
      START_LEVEL,
      IDLE,
      STORE_INPUT,
      CHECK_SOUND,
      BRANCH_ACTION,
      STORE_ACTION,
      PLAY_SOUND,
      CHECK_INPUT,
      BRANCH_CHECK_INPUT,
      INCREASE_T0,
      CHECK_ACTION,
      RESET_T0,

      // Zhao
      CHECK_LEVEL_1,
      BRANCH_LEVEL_1,
      LEVEL1_CHECK,
      LEVEL1_CORRECT,
      LEVEL1_WRONG,
      CHECK_LEVEL_2,
      BRANCH_LEVEL_2,
      LEVEL2_CHECK,
      LEVEL2_CORRECT,
      LEVEL2_WRONG,
      LEVEL3_CHECK,
      LEVEL3_CORRECT,
      LEVEL3_WRONG,
      RESET_INPUT,
      CHECK_ROUND_END,

      // CS
      BRANCH_GAME_TIMER,
      INCREASE_T4,
      CHECK_LEVEL_INCREASE,
      BRANCH_LEVEL_INCREASE,
      ADD_LEVEL,
      RESET_T4,
      GAME_END,

      // For freeplay usage
      FP_SOUND,
      FREEPLAY_SOUND    
    }; 
  }

  // ALUFN[4:0] operations
  const ADD = 5b00000;
  const SUB = 5b00001;
  const MUL = 5b00010;
  const DIV = 5b00011;
  const SHL = 5b00100;
  const SHR = 5b00101;
  const ROL = 5b00110;
  const SRA = 5b00111;
  const CMPEQ = 5b01011;
  const CMPLT = 5b01101;
  const CMPLE = 5b01111;
  const AND = 5b11000;
  const OR = 5b11110;
  const XOR = 5b10110;
  const A = 5b11010;
  const B = 5b11100;

  // reg addresses
  const SCORE = 3b000;
  const ACTION = 3b001;
  const INPUT = 3b010;
  const TIMER = 3b011;
  const T4 = 3b011;
  const LEVEL = 3b100;
  const T0 = 3b101;
  const CORRECT = 3b110;
  const R7 = 3b110;
  
  sig str;
  sig stf;
  
  always {
    //input_edges.in = c{inputs[3:1], ~inputs[0]};
    input_edges.in = inputs;
    clk_edge.in = c{slwclk, ~slwclk};
    str = clk_edge.out[1];
    stf = clk_edge.out[0];
    
    // Standard setting unless overwritten by cases
    alufn = 0;
    asel = 0;
    bsel = 0;
    werf = 0;
    wdsel = 0;
    lit = 0;
    rc = 0;
    ra = 0;
    rb = 0;
    bzsel = 0;

    if (rst) {
      game_fsm.d = game_fsm.START;
      // I think we do need set to set all the register to 0 though
      // Currently coded in the same manner as GAME_END, both should be the same
    } 
    else {
    
      case(game_fsm.q) {
        game_fsm.START: // not sure what to add for here
          if(start){
            game_fsm.d = game_fsm.START_LEVEL;
          } 
          
          if(|input_edges.out){
            game_fsm.d = game_fsm.FP_SOUND;
          }

        game_fsm.START_LEVEL:
          alufn = ADD;
          asel = b0;
          bsel = b01;
          werf = b1;
          lit = 4h1;
          ra = LEVEL;
          rc = LEVEL;
          wdsel = b00;
          game_fsm.d = game_fsm.IDLE;
          
        game_fsm.IDLE:
          if(clk_edge.out & 1){
            game_fsm.d = game_fsm.CHECK_SOUND;
          } else if(|input_edges.out){
            game_fsm.d = game_fsm.STORE_INPUT;
          }

        game_fsm.STORE_INPUT:
          werf = b1;
          rc = INPUT;
          wdsel = b10;
          bzsel = b0;
          if(clk_edge.out & 1){
            game_fsm.d = game_fsm.CHECK_SOUND;
          }

        game_fsm.CHECK_SOUND:
          alufn = B;
          bsel = b10;
          game_fsm.d = game_fsm.BRANCH_ACTION;

        game_fsm.BRANCH_ACTION:
          werf = b0;

          if(zvnpc[0]){
            game_fsm.d=game_fsm.STORE_ACTION;
          } else{
            game_fsm.d=game_fsm.CHECK_INPUT;
          }

        game_fsm.STORE_ACTION:
          werf = b1;
          rc = ACTION;
          wdsel = b01;
          game_fsm.d = game_fsm.PLAY_SOUND;

        game_fsm.PLAY_SOUND:
          werf = b0;
          bzsel = b1;
          game_fsm.d = game_fsm.IDLE;

        game_fsm.CHECK_INPUT:
          alufn = CMPLT;
          asel = b1;
          bsel = b10;
          werf = b1;
          lit = 4h2;
          ra = T0;
          rc = R7;
          wdsel = b00;
          game_fsm.d = game_fsm.BRANCH_CHECK_INPUT; //Might be too fast

        game_fsm.BRANCH_CHECK_INPUT:
          werf = b0;
          rb = R7;
          bzsel = b0;

          if(rb_data == 1){
            game_fsm.d = game_fsm.INCREASE_T0;
          } else{
            game_fsm.d = game_fsm.CHECK_ACTION; //Might be too fast
          }

        game_fsm.INCREASE_T0:
          alufn = ADD;
          asel = b00;
          bsel = b01;
          werf = b1;
          lit = 4h1;
          ra = T0;
          rc = T0;
          wdsel = b00;
          bzsel = b0;
          game_fsm.d = game_fsm.IDLE; //Might be too fast

        game_fsm.CHECK_ACTION:
          alufn = CMPEQ;
          asel = b00;
          bsel = b00;
          werf = b1;
          ra = INPUT;
          rb = ACTION;
          rc = CORRECT;
          wdsel = b00;
          bzsel = b0;
          game_fsm.d = game_fsm.RESET_T0; //Might be too fast

        game_fsm.RESET_T0:
          werf = b1;
          rc = T0;
          wdsel = b11;
          bzsel = b0;
          game_fsm.d = game_fsm.CHECK_LEVEL_1; //Might be too fast

        game_fsm.CHECK_LEVEL_1:
          alufn = CMPEQ; //CMPEQ
          asel = b00; // ra_data
          bsel = b01; // value of 1 to use for increment
          werf = b1; // write enabled
          lit = 4h1;
          ra = LEVEL; // reg for level
          rc = R7; // intermediate reg to store random values
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.BRANCH_LEVEL_1;

        game_fsm.BRANCH_LEVEL_1:
          werf = b0; // write disabled
          rb = R7; // intermediate reg to store random values
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          if (rb_data == 1) { // if level 1
            game_fsm.d = game_fsm.LEVEL1_CHECK;
          } else { // if not level 1
            game_fsm.d = game_fsm.CHECK_LEVEL_2; //Might be too fast
          }

        game_fsm.LEVEL1_CHECK:
          werf = b0; // write enabled
          rb = R7; // intermediate reg to store random values
          bzsel = b0; // no sound
          if (rb_data == 1) { // if action correct
            game_fsm.d = game_fsm.LEVEL1_CORRECT;
          } else { // if action wrong
            game_fsm.d = game_fsm.LEVEL1_WRONG;
          }

        game_fsm.LEVEL1_CORRECT:
          alufn = ADD; // ADD
          asel = b00;  // ra_data
          bsel = b00;  // rb_data
          werf = b1;   // write enabled
          ra = SCORE;  // reg for score
          rc = SCORE;  // reg for score
          wdsel = b00; // alu_data
          bzsel = b0;  // no sound
          game_fsm.d = game_fsm.RESET_INPUT;

        game_fsm.LEVEL1_WRONG:
          alufn = SUB; // SUB
          asel = b00; // ra_data
          bsel = b01; // value of 1 to use for increment
          werf = b1;  // write enabled
          lit = 4h1;
          ra = SCORE; // reg for score
          rc = SCORE; // reg for score
          wdsel = b00; // alu_data
          bzsel = b0;  // no sound
          game_fsm.d = game_fsm.RESET_INPUT;

        game_fsm.CHECK_LEVEL_2:
          alufn = CMPEQ; //CMPEQ
          asel = b00; // ra_data
          bsel = b01; // compare with timer; check if LSB != 1 (timer < 2)
          werf = b1; // write enabled
          lit = 4h2;
          ra = LEVEL; // reg for level
          rc = R7; // intermediate reg to store random values
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.BRANCH_LEVEL_2;

        game_fsm.BRANCH_LEVEL_2:
          werf = b0; // write disabled
          rb = R7; // intermediate reg to store random values
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          if (rb_data == 1) { // if level 2
            game_fsm.d = game_fsm.LEVEL2_CHECK;
          } else { // if not level 2
            game_fsm.d = game_fsm.LEVEL3_CHECK;
          }

        game_fsm.LEVEL2_CHECK:
          werf = b0; // write disabled
          rb = R7; // intermediate reg to store random values
          bzsel = b0; // no sound
          if (rb_data == 1) { // if action correct
            game_fsm.d = game_fsm.LEVEL2_CORRECT;
          } else { // if action wrong
            game_fsm.d = game_fsm.LEVEL2_WRONG;
          }

        game_fsm.LEVEL2_CORRECT:
          alufn = SHL; // SHL
          asel = b00; // ra_data
          bsel = b01; // value of 1 to use for increment
          werf = b1; // write enabled
          lit = 4h1;
          ra = SCORE; // reg for score
          rc = SCORE; // reg for score
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.RESET_INPUT; //Might be too fast

        game_fsm.LEVEL2_WRONG:
          alufn = SHR; // SHR
          asel = b00; // ra_data
          bsel = b01; // value of 1 to use for increment
          werf = b1; // write enabled
          lit = 4h1;
          ra = SCORE; // reg for score
          rc = SCORE; // reg for score
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.RESET_INPUT; //Might be too fast

        game_fsm.LEVEL3_CHECK:
          werf = b0; // write disabled
          rb = R7; // intermediate reg to store random values
          bzsel = b0; // no sound
          if (rb_data == 1) { // if action correct
            game_fsm.d = game_fsm.LEVEL3_CORRECT;
          } else { // if action wrong
            game_fsm.d = game_fsm.LEVEL3_WRONG; //Might be too fast
          }

        game_fsm.LEVEL3_CORRECT:
          alufn = ROL; // ROL
          asel = b00; // ra_data
          bsel = b01; // value of 1 to use for increment
          werf = b1; // write enabled
          lit = 4h1;
          ra = SCORE; // reg for score
          rc = SCORE; // reg for score
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.RESET_INPUT; //Might be too fast

        game_fsm.LEVEL3_WRONG: // This doesn't seem right
          alufn = ROL;  // ROL
          asel = b01;   // value 15 for ROL computation
          bsel = b01;   // value of 1 to use for increment
          werf = b1;    // write enabled
          lit = 4b1111;
          ra = SCORE;   // reg for score
          rc = SCORE;   // reg for score
          wdsel = b00;  // alu_data
          bzsel = b0;   // no sound
          game_fsm.d = game_fsm.RESET_INPUT; //Might be too fast

        game_fsm.RESET_INPUT:
          alufn = B; // B
          bsel = b01; // value of 1 to use for increment
          werf = b1; // write enabled
          lit = 4h1;
          rc = INPUT; // input
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.CHECK_ROUND_END; //Might be too fast

        game_fsm.CHECK_ROUND_END: //TODO: doesn't seem right
          alufn = CMPLT; // CMPLT
          asel = b00; // ra_data
          bsel = b01; // compare with timer check MSB == 1 (timer == 16)
          werf = b1; // write enabled
          lit = 4h10;
          ra = T4; // T4
          rc = R7; // intermediate reg to store random values
          wdsel = b00; // alu_data
          bzsel = b0; // no sound
          game_fsm.d = game_fsm.BRANCH_GAME_TIMER; //Might be too fast

        game_fsm.BRANCH_GAME_TIMER:
          werf = b0; // No write
          rb = R7;
          bzsel = b0; // No sound
          
          if (rb_data == 1) {
            game_fsm.d = game_fsm.INCREASE_T4; // If less than 8 rounds
          } else {
            game_fsm.d = game_fsm.CHECK_LEVEL_INCREASE; // If more than 8 rounds
          }
          
        game_fsm.INCREASE_T4:
          alufn = ADD; // ADD 1 to T4 register
          asel = b00;
          bsel = b01; // Constant 1
          werf = b1;
          lit = 4h1;
          ra = T4;
          rc = T4; // Write to rc
          wdsel = b00;
          bzsel = b0;
          game_fsm.d = game_fsm.IDLE; //Might be too fast

        game_fsm.CHECK_LEVEL_INCREASE:
          alufn = CMPLT; // Check that level < 3, 1 if level < 3, 0 otherwise
          asel = b01; // Constant 3
          bsel = b00;
          werf = b1; // Write to reg 7
          lit = b11;
          ra = LEVEL;
          rc = R7;
          wdsel = b00;
          bzsel = b00;
          
          game_fsm.d = game_fsm.BRANCH_LEVEL_INCREASE; //Might be too fast
          
        game_fsm.BRANCH_LEVEL_INCREASE:
          werf = b0;
          rb = R7; // Read from reg 7
          
          if (rb_data == 0) { // 0 if LEVEL < 3
            game_fsm.d = game_fsm.ADD_LEVEL;
          } else {
            game_fsm.d = game_fsm.GAME_END; //Might be too fast
          }

        game_fsm.ADD_LEVEL:
          alufn = ADD; // ADD 1 to level
          asel = b00;
          bsel = b01; // constant 1
          werf = b1;
          lit = 4h1;
          ra = LEVEL;
          rc = LEVEL; // Write to LEVEL register
          wdsel = b00;
          bzsel = b0;
          game_fsm.d = game_fsm.RESET_T4; //Might be too fast

        game_fsm.RESET_T4:
          werf = b1;
          rc = T4; // Setting T4 to 0
          wdsel = b11; // Constant 0
          bzsel = b0;
          game_fsm.d = game_fsm.IDLE; //Might be too fast

        game_fsm.GAME_END:
          if (rst) { // Check for reset button for game
            game_fsm.d = game_fsm.START;
          }
        
        game_fsm.FP_SOUND:
          werf = b0;
          bzsel = b1;
          game_fsm.d = game_fsm.START;

        default:
          game_fsm.d = game_fsm.START; //Set to start
    }

  }